package hexlet.code.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.querydsl.core.types.Predicate;
import hexlet.code.dto.TaskDtoRequest;
import hexlet.code.model.Label;
import hexlet.code.model.Task;
import hexlet.code.repository.TaskRepository;
import hexlet.code.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;

import java.util.NoSuchElementException;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A class that implements the application logic for processing requests
 * from the {@link hexlet.code.controller.TaskController}.
 * <p></p>
 * Contains a {@link TaskRepository}, {@link UserRepository} beans
 * for interacting with the tasks, users tables in the database.
 * <p></p>
 * It also contains a {@link UserService}, {@link TaskService}, {@link LabelService} to interact with services
 * to get the entities needed to create or update an entity {@link Task}.
 *
 * @author sobadxx
 * @see hexlet.code.controller.TaskController
 */
@Service
public class TaskService {
    @Autowired
    private ObjectMapper objectMapper = new ObjectMapper();
    @Autowired
    private TaskRepository taskRepository;
    @Autowired
    private UserService userService;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private TaskStatusService taskStatusService;
    @Autowired
    private LabelService labelService;

    /**
     * Retrieves an entity by its id.
     *
     * @param id entity id
     * @return result of the findById method
     */
    public Task getTask(Long id) {
        return findById(id);
    }

    /**
     * Returns all entities of type {@link Task} from the database.
     * <p></p>
     * A {@link Predicate} consist of query string parameters.
     * In case of passing a predicate, all entities matching the parameters will be returned.
     * Otherwise, all entities {@link Task} from the database are returned.
     *
     * @param predicate boolean predicate consisting of query parameters generated by querydsl
     * @return all entities of type {@link Task}
     * @see hexlet.code.controller.TaskController#getFilteredTasks(Predicate)
     */
    public Iterable<Task> getFilteredTasks(Predicate predicate) {
        return predicate == null ? taskRepository.findAll() : taskRepository.findAll(predicate);
    }

    /**
     * Creates an entity type {@link Task} and saves it to the database.
     *
     * @param taskDtoRequest {@link TaskDtoRequest} DTO-object with the fields necessary to create a {@link Task}
     * @return created {@link Task}
     * @see TaskDtoRequest
     * @see #getLabelsByIds(Set)
     */
    public Task createTask(TaskDtoRequest taskDtoRequest) {
        Task task = new Task();

        task.setName(taskDtoRequest.getName());
        task.setDescription(taskDtoRequest.getDescription());
        task.setTaskStatus(taskStatusService.getTaskStatusById(taskDtoRequest.getTaskStatusId()));
        task.setAuthor(userService.getCurrentUser());
        task.setExecutor(userService.getUserById(taskDtoRequest.getExecutorId()));
        if (taskDtoRequest.getLabelIds() != null) {
            task.setLabels(getLabelsByIds(taskDtoRequest.getLabelIds()));
        }
        return taskRepository.save(task);
    }

    /**
     * Updates an entity type {@link Task} and saves updated {@link Task} to the database.
     *
     * @param taskDtoRequest {@link TaskDtoRequest} DTO-object with the fields necessary to update a {@link Task}
     * @param id id of the {@link Task} whose data is being updated
     * @return updated {@link Task}
     * @see TaskDtoRequest
     * @see #getLabelsByIds(Set)
     */
    public Task updateTask(TaskDtoRequest taskDtoRequest, Long id) {
        Task taskToUpdate = findById(id);
        if (taskToUpdate.getAuthor().getId() != userService.getCurrentUser().getId()) {
            throw new AccessDeniedException("You cannot edit other users tasks");
        }
        taskToUpdate.setName(taskDtoRequest.getName());
        taskToUpdate.setDescription(taskDtoRequest.getDescription());
        taskToUpdate.setExecutor(userService.getUserById(taskDtoRequest.getExecutorId()));
        taskToUpdate.setTaskStatus(taskStatusService.getTaskStatusById(taskDtoRequest.getTaskStatusId()));
        if (taskDtoRequest.getLabelIds() != null) {
            taskToUpdate.setLabels(getLabelsByIds(taskDtoRequest.getLabelIds()));
        }
        return taskRepository.save(taskToUpdate);
    }

    /**
     * Delete the {@link Task} object in the database.
     *
     * @param id id of the {@link Task} whose is being deleted
     */
    public void deleteTask(Long id) {
        Task taskToDelete = findById(id);
        if (taskToDelete.getAuthor().getId() != userService.getCurrentUser().getId()) {
            throw new AccessDeniedException("You cannot delete other users tasks");
        }
        taskRepository.delete(taskToDelete);
    }

    /**
     * Retrieves an entity by its id.
     *
     * @param id entity id
     * @return the entity with given id
     * @throws NoSuchElementException if Entity with {@literal id} not found
     */
    private Task findById(Long id) {
        return taskRepository.findById(id)
                .orElseThrow(
                        () -> new NoSuchElementException("Task with " + id + " not found")
                );
    }

    /**
     * Retrieves an {@link Label} {@link Set} entities by its {@link Set} ids.
     *
     * @param labelsIds {@link Set} of {@link Label} ids
     * @return {@link Set} {@link Label} entities mapped by {@link Set} ids
     */
    private Set<Label> getLabelsByIds(Set<Long> labelsIds) {
        return labelsIds.stream()
                .map(id -> labelService.getLabel(id))
                .collect(Collectors.toSet());
    }
}
